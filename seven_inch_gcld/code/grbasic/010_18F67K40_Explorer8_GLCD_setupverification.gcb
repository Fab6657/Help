/*
    A demonstration program for GCGB and GCB.
    --------------------------------------------------------------------------------

    The program us designed for Microchipâ€™s Explorer 8 Development Board. The Explorer 8 Development board supports 8/14/20/28/40-pin 8-bit PIC microcontrollers as well as up to 80-pin PIMmounted devices. 
    The demos included in this document are developed for high pin count devices (64 pin). 
    
    GCBASIC for these devices can be downloaded from the GCBASIC web site at https://sourceforge.net/projects/gcbasic/
    
*/
'''@author    Evan R. Venn   
'''@license   GPL
'''@version   1.02   
'''@date      2023-11-20
'''********************************************************************************


#chip 18F67K40, 64
    #option explicit 
    #config MCLRE = EXTMCLR

    // PPS Tool version: 0.0.6.3
        // Generated for 18f67k40
        
        #startup InitPPS, 85
        #define PPSToolPart 18f67k40

        Sub InitPPS
                
                #ifdef USART_BAUD_RATE
                    'Module: EUSART1
                    RC6PPS = 0x000C    'TX1 > RC6
                #endif

                #ifdef oneof(LCD_HARDWARESPI, LT686_HARDWARESPI)
                    // This is conditional to support Hardware SPI
                    SSP1CLKPPS = 0x13;   //RC3->MSSP1:SCK1;    
                    RC3PPS = 0x19;   //RC3->MSSP1:SCK1;    
                    RC5PPS = 0x1A;   //RC5->MSSP1:SDO1;    
                    SSP1DATPPS = 0x14;   //RC4->MSSP1:SDI1;  
                #endif

                'Module: CCP1
                RC2PPS = 0x0005    'CCP1 > RC2
                CCP1PPS = 0x0012    'RC2 > CCP1 (bi-directional)
                RE5PPS = 0x0005    'CCP1 > RE5
                CCP1PPS = 0x0025    'RE5 > CCP1 (bi-directional)
                RE7PPS = 0x0005    'CCP1 > RE7
                CCP1PPS = 0x0027    'RE7 > CCP1 (bi-directional)
            
            End Sub

    // Constants - Serial support
        #define USART_BAUD_RATE 9600
        #define USART_TX_BLOCKING
        #define USART_DELAY OFF

    // Constants - GLCD connectivity type;controls whether to use HW SPI 
        #define GLCD_LT686_1024x800
        // #define GLCD_LT686_800x480

        #define GLCD_TYPE_LT686 99
        #define LT686_HARDWARESPI
        #define HWSPIMODE MASTERFAST
        'Pin mappings for GLCD SPI
        // If PPS enabled then ports must match PPS config
        #define GLCD_DO          portc.5
        #define GLCD_DI          portc.4
        #define GLCD_SCK         portc.3
        // Ports to control GLCD
        #define GLCD_INT         portc.33
        #define GLCD_RESET       portb.52
        #define GCLD_CS          porta.22
        
        
        

           


    //Constants - LCD connectivity type;controls whether to use HW SPI; The inter character delay
    #define LCD_IO 14
        // #define LCD_HARDWARESPI
        #define LCD_SPEED FAST
        #define HWSPIMODE MASTERFAST
        //These are phyiscal connections from the expander to the LCD.  These are automatically set in the library and are shown here purely for clarity.
            #define LCD_SPI_EXPD_ADDRESS            0x40
            #define LCD_SPI_EXPANDER_E_ADDRESS      0x40     // GPA6 on the expander
            #define LCD_SPI_EXPANDER_RS_ADDRESS     0x80     // GPA7 on the expander   

        'Pin mappings for LCD IO SPI Expander
        #define LCD_SPI_DO          portc.5
        #define LCD_SPI_SCK         portc.3
        #define LCD_SPI_CS          porta.2
        // Optional(s) reset Port.Pin connection to expander, select one.
            // #define LCD_SPI_RESET_IN       portb.5
            #define LCD_SPI_RESET_OUT      portb.5

; ----- Main body of program commences here.

    // Hardware configuration
        #define SWITCH_S1_PORT      PORTB.0
        #define SWITCH_S2_PORT      PORTA.5
        #define LED_D1              PORTD.0
        #define LED_D2              PORTD.1
        #define LED_D3              PORTD.2
        #define LED_D4              PORTD.3
        #define LED_D5              PORTB.0
        #define LED_D6              PORTB.1
        #define LED_D7              PORTB.2
        #define LED_D8              PORTB.3
        #define CCPPWM_D1           PORTE.7
        #define CCPPWM_D2           PORTE.5
        #define CCPPWM_D3           PORTC.2
        
        Dir SWITCH_S1_PORT  In
        Dir SWITCH_S2_PORT  In
        Dir LED_D1          Out
        Dir LED_D2          Out
        Dir LED_D3          Out
        Dir LED_D4          Out
        Dir LED_D5          Out
        Dir LED_D6          Out
        Dir LED_D7          Out
        Dir LED_D8          Out
        Dir CCPPWM_D1       Out
        Dir CCPPWM_D2       Out
        Dir CCPPWM_D3       Out
        // Ensure SPI_Expander Ports are outputs.  These WILL have been changed during the INIT phase of the chip.
        Dir LCD_SPI_DO      Out: LCD_SPI_DO     = 0
        Dir LCD_SPI_SCK     Out: LCD_SPI_SCK    = 0

    // Common macro and constants
        #define LEDS_OFF            LED_D8=0:LED_D7=0:LED_D6=0:LED_D5=0:LED_D4=0:LED_D3=0:LED_D2=0:LED_D1=0
        #define PRESSED             1
        #define NOT_PRESSED         0
        #define RUNNING             1
        #define NOT_RUNNING         0
        #define RIGHTDIRECTION      1
        #define LEFTDIRECTION       0        
        #define MAX_LABS            13


    // Variable Definitions
    Dim switchEvent as Byte:        switchEvent = 0
    Dim btnState as Byte:           btnState = NOT_PRESSED

    #ifdef USART_BAUD_RATE
        HserPrintCRLF
        HserPrint "Welcome to Explorer 8"
        HserPrintCRLF
        HserPrint "GCBASIC - Anobium   2023"
        HserPrintCRLF
    #endif

    Print "    Welcome     "
    Locate 1,0
    Print "  to Explorer 8 "
    wait 1 s
    CLS
    Print "    GCBASIC     "
    Locate 1,0
    Print " Anobium   2023 "
    wait 5 s
    CLS
    Print "    Welcome     "
    Locate 1,0
    Print "  to Explorer 8 "


/*
    Do Forever
        // Check button state
        checkButtonS2
        
        if switchEvent = 1 then
            // Do stuff
        End if     

    Loop
*/


'''Initialise the GLCD device
Sub InitGLCD_LT686

  #if GLCD_TYPE = GLCD_TYPE_LT686

    '  Mapped to global variables to same RAM
    ' dim LT686_GLCD_HEIGHT, LT686_GLCD_WIDTH as word

    'Setup code for LT686 controllers

    #ifdef LT686_SPI_MODE_SCRIPT 1
        'SPI mode!!!
    'Pin directions
    Dir LT686_CS Out
    Dir LT686_DC Out
    Dir LT686_RST Out

    #if bit(LT686_DI)
      Dir LT686_DI In
    #endif
    Dir LT686_DO Out
    Dir LT686_SCK Out

    #ifdef LT686_HardwareSPI
      ' harware SPI mode
      asm showdebug SPI constant used equates to HWSPIMODESCRIPT
      SPIMode HWSPIMODESCRIPT, 0
    #endif

   Set LT686_CS On
   Set LT686_DC On
    #endif


    #ifdef LT686_8BIT_MODE_SCRIPT 1
    '8bit bus mode !!
      dir  LT686_DB7 OUT
      dir  LT686_DB6 OUT
      dir  LT686_DB5 OUT
      dir  LT686_DB4 OUT
      dir  LT686_DB3 OUT
      dir  LT686_DB2 OUT
      dir  LT686_DB1 OUT
      dir  LT686_DB0 OUT

      'Set pin directions
      Dir LT686_RD  Out
      Dir LT686_WR  Out
      Dir LT686_RS  Out
      Dir LT686_CS  Out
      Dir LT686_RST Out

      Set LT686_RD On
      Set LT686_WR On
      Set LT686_RS On
      set LT686_CS ON
      Set LT686_RST On
    #endif

    'Reset display
    Wait 50 ms
    Set LT686_RST On
    Wait 15 ms
    'Reset sequence (lower line for at least 10 us)
    Set LT686_RST Off
    Wait 15 us
    Set LT686_RST On
    Wait 15 ms

  SendCommand_LT686(0xEF)
  SendData_LT686(0x03)
  SendData_LT686(0x80)
  SendData_LT686(0x02)

  SendCommand_LT686(0xCF)
  SendData_LT686(0x00)
  SendData_LT686(0XC1)
  SendData_LT686(0X30)

  SendCommand_LT686(0xED)
  SendData_LT686(0x64)
  SendData_LT686(0x03)
  SendData_LT686(0X12)
  SendData_LT686(0X81)

  SendCommand_LT686(0xE8)
  SendData_LT686(0x85)
  SendData_LT686(0x00)
  SendData_LT686(0x78)

  SendCommand_LT686(0xCB)
  SendData_LT686(0x39)
  SendData_LT686(0x2C)
  SendData_LT686(0x00)
  SendData_LT686(0x34)
  SendData_LT686(0x02)

  SendCommand_LT686(0xF7)
  SendData_LT686(0x20)

  SendCommand_LT686(0xEA)
  SendData_LT686(0x00)
  SendData_LT686(0x00)

  SendCommand_LT686(LT686_PWCTR1)    'Power control
  SendData_LT686(0x2B)   'VRH[5:0]

  SendCommand_LT686(LT686_PWCTR2)    'Power control
  SendData_LT686(0x10)   'SAP[2:0];BT[3:0]

  SendCommand_LT686(LT686_VMCTR1)    'VCM control
  SendData_LT686(0x3e) '???????
  SendData_LT686(0x28)

  SendCommand_LT686(LT686_VMCTR2)    'VCM control2
  SendData_LT686(0x86)  '--

  SendCommand_LT686(LT686_MADCTL)    ' Memory Access Control
  SendData_LT686(LT686_MADCTL_MX | LT686_MADCTL_BGR)

  SendCommand_LT686(LT686_PIXFMT)
  SendData_LT686(0x55)

  SendCommand_LT686(LT686_FRMCTR1)
  SendData_LT686(0x00)
  SendData_LT686(0x18)

  SendCommand_LT686(LT686_DFUNCTR)    ' Display Function Control
  SendData_LT686(0x08)
  SendData_LT686(0x82)
  SendData_LT686(0x27)

  SendCommand_LT686(0xF2)    ' 3Gamma Function Disable
  SendData_LT686(0x00)

  SendCommand_LT686(LT686_GAMMASET)    'Gamma curve selected
  SendData_LT686(0x01)

  SendCommand_LT686(LT686_GMCTRP1)    'Set Gamma
  SendData_LT686(0x0F)
  SendData_LT686(0x31)
  SendData_LT686(0x2B)
  SendData_LT686(0x0C)
  SendData_LT686(0x0E)
  SendData_LT686(0x08)
  SendData_LT686(0x4E)
  SendData_LT686(0xF1)
  SendData_LT686(0x37)
  SendData_LT686(0x07)
  SendData_LT686(0x10)
  SendData_LT686(0x03)
  SendData_LT686(0x0E)
  SendData_LT686(0x09)
  SendData_LT686(0x00)

  SendCommand_LT686(LT686_GMCTRN1)    'Set Gamma
  SendData_LT686(0x00)
  SendData_LT686(0x0E)
  SendData_LT686(0x14)
  SendData_LT686(0x03)
  SendData_LT686(0x11)
  SendData_LT686(0x07)
  SendData_LT686(0x31)
  SendData_LT686(0xC1)
  SendData_LT686(0x48)
  SendData_LT686(0x08)
  SendData_LT686(0x0F)
  SendData_LT686(0x0C)
  SendData_LT686(0x31)
  SendData_LT686(0x36)
  SendData_LT686(0x0F)

  SendCommand_LT686(LT686_SLPOUT)    'Exit Sleep
  wait 150 ms
  SendCommand_LT686(LT686_DISPON)    'Display on

  'Default Colours
  #ifdef DEFAULT_GLCDBACKGROUND
    GLCDBACKGROUND = DEFAULT_GLCDBACKGROUND
  #endif

  #ifndef DEFAULT_GLCDBACKGROUND
    GLCDBACKGROUND = LT686_BLACK
  #endif


  GLCDForeground = LT686_WHITE

    'Variables required for device
    LT686_GLCD_WIDTH = GLCD_WIDTH
    LT686_GLCD_HEIGHT = GLCD_HEIGHT
    #ifndef GLCD_OLED_FONT
      GLCDFontWidth = 6
    #endif

    #ifdef GLCD_OLED_FONT
      GLCDFontWidth = 5
    #endif

  GLCDfntDefault = 0
  GLCDfntDefaultsize = 1
  GLCDfntDefaultHeight = 7  'used by GLCDPrintString and GLCDPrintStringLn

  #endif

  GLCDRotateState = Portrait
  'Clear screen
  GLCDCLS

End Sub

'Sub
'''Clears the GLCD screen
Sub GLCDCLS_LT686 ( Optional In  GLCDBACKGROUND as word = GLCDBACKGROUND )

End Sub






















Function checkButtonS1 as Bit

        // Toggle the port to Input/High to cater for the attached LED and the Switch - this action is specific to the 18F67K40 in the Explorer 8 board where the S1 is also tied to the LED5.
        // This action sets the port in a state where the S1 switch state can read.
        // Typically not required
        DIR SWITCH_S1_PORT OUT
        SWITCH_S1_PORT = 1
        DIR SWITCH_S1_PORT IN
        SWITCH_S1_PORT = 1

        // The Switch is normally tied to VDD ...when it is pressed, the switch port is connected to GND
        // Return the value
        checkButtonS1 = SWITCH_S1_PORT

End Function

Sub checkButtonS2

    if btnState = NOT_PRESSED Then
        if SWITCH_S2_PORT = 0 Then  
            wait 100 ms
            btnState = PRESSED
        end If
    else if SWITCH_S2_PORT = 1 Then
            btnState = NOT_PRESSED
            switchEvent = 1                                                   
    end if

End Sub

