;Program compiled by GCBASIC (1.01.00 2023-09-30 (Windows 64 bit) : Build 1289) for Microchip MPASM/MPLAB-X Assembler using FreeBASIC 1.07.1/2023-10-18 CRC29
;Need help? 
;  See the GCBASIC forums at http://sourceforge.net/projects/gcbasic/forums,
;  Check the documentation and Help at http://gcbasic.sourceforge.net/help/,
;or, email us:
;   w_cholmondeley at users dot sourceforge dot net
;   evanvennn at users dot sourceforge dot net

;********************************************************************************

;Set up the assembler options (Chip type, clock source, other bits and pieces)
 LIST p=18F67K40, r=DEC
#include <P18F67K40.inc>
 CONFIG CPD = OFF, CP = OFF, LVP = OFF, WRTD = OFF, WRTB = OFF, WDTE = OFF, XINST = OFF, MCLRE = EXTMCLR, FCMEN = ON, CLKOUTEN = OFF, RSTOSC = HFINTOSC_1MHZ, FEXTOSC = OFF

;********************************************************************************

;Set aside memory locations for variables
BTNSTATE                         EQU      10          ; 0XA
COMPORT                          EQU      11          ; 0XB
DELAYTEMP                        EQU       0          ; 0X0
DELAYTEMP2                       EQU       1          ; 0X1
GLCDBACKGROUND                   EQU      12          ; 0XC
GLCDBACKGROUND_H                 EQU      13          ; 0XD
GLCDDEVICEHEIGHT                 EQU      14          ; 0XE
GLCDDEVICEHEIGHT_H               EQU      15          ; 0XF
GLCDDEVICEWIDTH                  EQU      16          ; 0X10
GLCDDEVICEWIDTH_H                EQU      17          ; 0X11
GLCDFNTDEFAULT                   EQU      18          ; 0X12
GLCDFNTDEFAULTHEIGHT             EQU      19          ; 0X13
GLCDFNTDEFAULTSIZE               EQU      20          ; 0X14
GLCDFONTWIDTH                    EQU      21          ; 0X15
GLCDFOREGROUND                   EQU      22          ; 0X16
GLCDFOREGROUND_H                 EQU      23          ; 0X17
GLCDROTATESTATE                  EQU      24          ; 0X18
HSERPRINTCRLFCOUNT               EQU      25          ; 0X19
LCDBYTE                          EQU      26          ; 0X1A
LCDCOLUMN                        EQU      27          ; 0X1B
LCDLINE                          EQU      28          ; 0X1C
LCDVALUE                         EQU      29          ; 0X1D
LCD_STATE                        EQU      30          ; 0X1E
PRINTLEN                         EQU      31          ; 0X1F
SERDATA                          EQU      32          ; 0X20
SPICLOCKMODE                     EQU      33          ; 0X21
SPICURRENTMODE                   EQU      34          ; 0X22
STRINGPOINTER                    EQU      35          ; 0X23
SWITCHEVENT                      EQU      36          ; 0X24
SYSBYTETEMPA                     EQU       5          ; 0X5
SYSBYTETEMPB                     EQU       9          ; 0X9
SYSBYTETEMPX                     EQU       0          ; 0X0
SYSCALCTEMPA                     EQU       5          ; 0X5
SYSLCDTEMP                       EQU      37          ; 0X25
SYSPRINTDATAHANDLER              EQU      38          ; 0X26
SYSPRINTDATAHANDLER_H            EQU      39          ; 0X27
SYSPRINTTEMP                     EQU      40          ; 0X28
SYSREPEATTEMP1                   EQU      41          ; 0X29
SYSREPEATTEMP2                   EQU      42          ; 0X2A
SYSSTRINGA                       EQU       7          ; 0X7
SYSSTRINGA_H                     EQU       8          ; 0X8
SYSSTRINGLENGTH                  EQU       6          ; 0X6
SYSSTRINGPARAM1                  EQU    3537          ; 0XDD1
SYSTEMP1                         EQU      43          ; 0X2B
SYSTEMP2                         EQU      44          ; 0X2C
SYSWAITTEMP10US                  EQU       5          ; 0X5
SYSWAITTEMPMS                    EQU       2          ; 0X2
SYSWAITTEMPMS_H                  EQU       3          ; 0X3
SYSWAITTEMPS                     EQU       4          ; 0X4
SYSWAITTEMPUS                    EQU       5          ; 0X5
SYSWAITTEMPUS_H                  EQU       6          ; 0X6
__LCDBYTE                        EQU      45          ; 0X2D
__LCDREG                         EQU      46          ; 0X2E
__LCD_OUTBUFFER                  EQU      47          ; 0X2F
__LCD_OUTBUFFERCOUNT             EQU      48          ; 0X30

;********************************************************************************

;ALIAS VARIABLES
AFSR0                            EQU 4073
AFSR0_H                          EQU 4074

;********************************************************************************

;VECTORS
	ORG	0
	GOTO	BASPROGRAMSTART
	ORG	8
	RETFIE

;********************************************************************************

;START OF PROGRAM MEMORY PAGE 0
	ORG	12
BASPROGRAMSTART
;CALL INITIALISATION ROUTINES
	RCALL	INITSYS
	RCALL	INITPPS
	RCALL	INITUSART
	RCALL	INITLCD
;AUTOMATIC PIN DIRECTION SETTING
	BCF	TRISA,0,ACCESS

;START OF THE MAIN PROGRAM
;
;A demonstration program for GCGB and GCB.
;--------------------------------------------------------------------------------
;
;The program us designed for Microchipâ€™s Explorer 8 Development Board. The Explorer 8 Development board supports 8/14/20/28/40-pin 8-bit PIC microcontrollers as well as up to 80-pin PIMmounted devices.
;The demos included in this document are developed for high pin count devices (64 pin).
;
;GCBASIC for these devices can be downloaded from the GCBASIC web site at https://sourceforge.net/projects/gcbasic/
;
;
;''@author    Evan R. Venn
;''@license   GPL
;''@version   1.02
;''@date      2023-11-20
;''********************************************************************************
;PPS Tool version: 0.0.6.3
;Generated for 18f67k40
;Constants - Serial support
;Constants - GLCD connectivity type;controls whether to use HW SPI
;If PPS enabled then ports must match PPS config
;Ports to control GLCD
;Constants - LCD connectivity type;controls whether to use HW SPI; The inter character delay
;#define LCD_HARDWARESPI
;These are phyiscal connections from the expander to the LCD.  These are automatically set in the library and are shown here purely for clarity.
;Pin mappings for LCD IO SPI Expander
;Optional(s) reset Port.Pin connection to expander, select one.
;#define LCD_SPI_RESET_IN       portb.5
;----- Main body of program commences here.
;Hardware configuration
;Dir SWITCH_S1_PORT  In
	BSF	TRISB,0,ACCESS
;Dir SWITCH_S2_PORT  In
	BSF	TRISA,5,ACCESS
;Dir LED_D1          Out
	BCF	TRISD,0,ACCESS
;Dir LED_D2          Out
	BCF	TRISD,1,ACCESS
;Dir LED_D3          Out
	BCF	TRISD,2,ACCESS
;Dir LED_D4          Out
	BCF	TRISD,3,ACCESS
;Dir LED_D5          Out
	BCF	TRISB,0,ACCESS
;Dir LED_D6          Out
	BCF	TRISB,1,ACCESS
;Dir LED_D7          Out
	BCF	TRISB,2,ACCESS
;Dir LED_D8          Out
	BCF	TRISB,3,ACCESS
;Dir CCPPWM_D1       Out
	BCF	TRISE,7,ACCESS
;Dir CCPPWM_D2       Out
	BCF	TRISE,5,ACCESS
;Dir CCPPWM_D3       Out
	BCF	TRISC,2,ACCESS
;Ensure SPI_Expander Ports are outputs.  These WILL have been changed during the INIT phase of the chip.
;Dir LCD_SPI_DO      Out: LCD_SPI_DO     = 0
	BCF	TRISC,5,ACCESS
;Dir LCD_SPI_DO      Out: LCD_SPI_DO     = 0
	BCF	LATC,5,ACCESS
;Dir LCD_SPI_SCK     Out: LCD_SPI_SCK    = 0
	BCF	TRISC,3,ACCESS
;Dir LCD_SPI_SCK     Out: LCD_SPI_SCK    = 0
	BCF	LATC,3,ACCESS
;Common macro and constants
;Variable Definitions
;Dim switchEvent as Byte:        switchEvent = 0
;Dim switchEvent as Byte:        switchEvent = 0
	CLRF	SWITCHEVENT,ACCESS
;Dim btnState as Byte:           btnState = NOT_PRESSED
;Dim btnState as Byte:           btnState = NOT_PRESSED
	CLRF	BTNSTATE,ACCESS
;HserPrintCRLF
	MOVLW	1
	MOVWF	HSERPRINTCRLFCOUNT,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
	RCALL	HSERPRINTCRLF
;HserPrint "Welcome to Explorer 8"
	LFSR	1,SYSSTRINGPARAM1
	MOVLW	LOW STRINGTABLE1
	MOVWF	TBLPTRL,ACCESS
	MOVLW	HIGH STRINGTABLE1
	MOVWF	TBLPTRH,ACCESS
	MOVLW	UPPER STRINGTABLE1
	MOVWF	TBLPTRU,ACCESS
	RCALL	SYSREADSTRING
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER,ACCESS
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER_H,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
;USING SYSSTRINGPARAM1*21
	RCALL	HSERPRINT815
;HserPrintCRLF
	MOVLW	1
	MOVWF	HSERPRINTCRLFCOUNT,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
	RCALL	HSERPRINTCRLF
;HserPrint "GCBASIC - Anobium   2023"
	LFSR	1,SYSSTRINGPARAM1
	MOVLW	LOW STRINGTABLE2
	MOVWF	TBLPTRL,ACCESS
	MOVLW	HIGH STRINGTABLE2
	MOVWF	TBLPTRH,ACCESS
	MOVLW	UPPER STRINGTABLE2
	MOVWF	TBLPTRU,ACCESS
	RCALL	SYSREADSTRING
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER,ACCESS
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER_H,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
;USING SYSSTRINGPARAM1*24
	RCALL	HSERPRINT815
;HserPrintCRLF
	MOVLW	1
	MOVWF	HSERPRINTCRLFCOUNT,ACCESS
	MOVLW	1
	MOVWF	COMPORT,ACCESS
	RCALL	HSERPRINTCRLF
;Print "    Welcome     "
	LFSR	1,SYSSTRINGPARAM1
	MOVLW	LOW STRINGTABLE3
	MOVWF	TBLPTRL,ACCESS
	MOVLW	HIGH STRINGTABLE3
	MOVWF	TBLPTRH,ACCESS
	MOVLW	UPPER STRINGTABLE3
	MOVWF	TBLPTRU,ACCESS
	RCALL	SYSREADSTRING
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER,ACCESS
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER_H,ACCESS
;USING SYSSTRINGPARAM1*16
	RCALL	PRINT612
;Locate 1,0
	MOVLW	1
	MOVWF	LCDLINE,ACCESS
	CLRF	LCDCOLUMN,ACCESS
	RCALL	LOCATE
;Print "  to Explorer 8 "
	LFSR	1,SYSSTRINGPARAM1
	MOVLW	LOW STRINGTABLE4
	MOVWF	TBLPTRL,ACCESS
	MOVLW	HIGH STRINGTABLE4
	MOVWF	TBLPTRH,ACCESS
	MOVLW	UPPER STRINGTABLE4
	MOVWF	TBLPTRU,ACCESS
	RCALL	SYSREADSTRING
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER,ACCESS
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER_H,ACCESS
;USING SYSSTRINGPARAM1*16
	RCALL	PRINT612
;wait 1 s
	MOVLW	1
	MOVWF	SYSWAITTEMPS,ACCESS
	RCALL	DELAY_S
;CLS
	RCALL	CLS
;Print "    GCBASIC     "
	LFSR	1,SYSSTRINGPARAM1
	MOVLW	LOW STRINGTABLE5
	MOVWF	TBLPTRL,ACCESS
	MOVLW	HIGH STRINGTABLE5
	MOVWF	TBLPTRH,ACCESS
	MOVLW	UPPER STRINGTABLE5
	MOVWF	TBLPTRU,ACCESS
	RCALL	SYSREADSTRING
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER,ACCESS
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER_H,ACCESS
;USING SYSSTRINGPARAM1*16
	RCALL	PRINT612
;Locate 1,0
	MOVLW	1
	MOVWF	LCDLINE,ACCESS
	CLRF	LCDCOLUMN,ACCESS
	RCALL	LOCATE
;Print " Anobium   2023 "
	LFSR	1,SYSSTRINGPARAM1
	MOVLW	LOW STRINGTABLE6
	MOVWF	TBLPTRL,ACCESS
	MOVLW	HIGH STRINGTABLE6
	MOVWF	TBLPTRH,ACCESS
	MOVLW	UPPER STRINGTABLE6
	MOVWF	TBLPTRU,ACCESS
	RCALL	SYSREADSTRING
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER,ACCESS
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER_H,ACCESS
;USING SYSSTRINGPARAM1*16
	RCALL	PRINT612
;wait 5 s
	MOVLW	5
	MOVWF	SYSWAITTEMPS,ACCESS
	RCALL	DELAY_S
;CLS
	RCALL	CLS
;Print "    Welcome     "
	LFSR	1,SYSSTRINGPARAM1
	MOVLW	LOW STRINGTABLE3
	MOVWF	TBLPTRL,ACCESS
	MOVLW	HIGH STRINGTABLE3
	MOVWF	TBLPTRH,ACCESS
	MOVLW	UPPER STRINGTABLE3
	MOVWF	TBLPTRU,ACCESS
	RCALL	SYSREADSTRING
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER,ACCESS
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER_H,ACCESS
;USING SYSSTRINGPARAM1*16
	RCALL	PRINT612
;Locate 1,0
	MOVLW	1
	MOVWF	LCDLINE,ACCESS
	CLRF	LCDCOLUMN,ACCESS
	RCALL	LOCATE
;Print "  to Explorer 8 "
	LFSR	1,SYSSTRINGPARAM1
	MOVLW	LOW STRINGTABLE4
	MOVWF	TBLPTRL,ACCESS
	MOVLW	HIGH STRINGTABLE4
	MOVWF	TBLPTRH,ACCESS
	MOVLW	UPPER STRINGTABLE4
	MOVWF	TBLPTRU,ACCESS
	RCALL	SYSREADSTRING
	MOVLW	LOW SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER,ACCESS
	MOVLW	HIGH SYSSTRINGPARAM1
	MOVWF	SYSPRINTDATAHANDLER_H,ACCESS
;USING SYSSTRINGPARAM1*16
	RCALL	PRINT612
;InitGLCD
	RCALL	INITGLCD_LT686
;
;Do Forever
;// Check button state
;checkButtonS2
;
;if switchEvent = 1 then
;// Do stuff
;End if
;
;Loop
;
;****************************************************************************************************************************************
;**************************************************************************************************
;Pin mappings for LT686
;''Initialise the GLCD device
;Sub
;''Clears the GLCD screen
BASPROGRAMEND
	SLEEP
	BRA	BASPROGRAMEND

;********************************************************************************

;SOURCE: LCD.H (510)
CLS
;Sub to clear the LCD
;SET LCD_RS OFF
	BCF	SYSLCDTEMP,1,ACCESS
;Clear screen
;LCDWriteByte (0b00000001)
	MOVLW	1
	MOVWF	LCDBYTE,ACCESS
	RCALL	LCD_SPI_EXPANDER_NORMALWRITEBYTE
;Wait 4 ms
	MOVLW	4
	MOVWF	SYSWAITTEMPMS,ACCESS
	CLRF	SYSWAITTEMPMS_H,ACCESS
	RCALL	DELAY_MS
;Move to start of visible DDRAM
;LCDWriteByte(0x80)
	MOVLW	128
	MOVWF	LCDBYTE,ACCESS
	RCALL	LCD_SPI_EXPANDER_NORMALWRITEBYTE
;Wait 50 us
	MOVLW	1
	MOVWF	DELAYTEMP2,ACCESS
DELAYUSO2
	CLRF	DELAYTEMP,ACCESS
DELAYUS2
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS2
	DECFSZ	DELAYTEMP2,F,ACCESS
	BRA	DELAYUSO2
	MOVLW	9
	MOVWF	DELAYTEMP,ACCESS
DELAYUS3
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS3
	RETURN

;********************************************************************************

DELAY_10US
D10US_START
	MOVLW	52
	MOVWF	DELAYTEMP,ACCESS
DELAYUS0
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS0
	DECFSZ	SYSWAITTEMP10US, F,ACCESS
	BRA	D10US_START
	RETURN

;********************************************************************************

DELAY_MS
	INCF	SYSWAITTEMPMS_H, F,ACCESS
DMS_START
	MOVLW	129
	MOVWF	DELAYTEMP2,ACCESS
DMS_OUTER
	MOVLW	40
	MOVWF	DELAYTEMP,ACCESS
DMS_INNER
	DECFSZ	DELAYTEMP, F,ACCESS
	BRA	DMS_INNER
	DECFSZ	DELAYTEMP2, F,ACCESS
	BRA	DMS_OUTER
	DECFSZ	SYSWAITTEMPMS, F,ACCESS
	BRA	DMS_START
	DECFSZ	SYSWAITTEMPMS_H, F,ACCESS
	BRA	DMS_START
	RETURN

;********************************************************************************

DELAY_S
DS_START
	MOVLW	232
	MOVWF	SYSWAITTEMPMS,ACCESS
	MOVLW	3
	MOVWF	SYSWAITTEMPMS_H,ACCESS
	RCALL	DELAY_MS
	DECFSZ	SYSWAITTEMPS, F,ACCESS
	BRA	DS_START
	RETURN

;********************************************************************************

;SOURCE: 010_18F67K40_EXPLORER8_GLCD_SETUPVERIFICATION.GCB (349)
GLCDCLS_LT686
	RETURN

;********************************************************************************

;OVERLOADED SIGNATURE: STRING:BYTE:, SOURCE: USART.H (2424)
HSERPRINT815
;PrintLen = PrintData(0)
	MOVFF	SYSPRINTDATAHANDLER,AFSR0
	MOVFF	SYSPRINTDATAHANDLER_H,AFSR0_H
	MOVFF	INDF0,PRINTLEN
;If PrintLen <> 0 then
	MOVF	PRINTLEN,F,ACCESS
	BTFSC	STATUS, Z,ACCESS
	BRA	ENDIF12
;Write Data
;for SysPrintTemp = 1 to PrintLen
	MOVLW	1
	MOVWF	SYSPRINTTEMP,ACCESS
SYSFORLOOP3
;HSerSend(PrintData(SysPrintTemp),comport )
	MOVF	SYSPRINTTEMP,W,ACCESS
	ADDWF	SYSPRINTDATAHANDLER,W,ACCESS
	MOVWF	AFSR0,ACCESS
	MOVLW	0
	ADDWFC	SYSPRINTDATAHANDLER_H,W,ACCESS
	MOVWF	AFSR0_H,ACCESS
	MOVFF	INDF0,SERDATA
	RCALL	HSERSEND805
;next
;POSITIVE VALUE STEP HANDLER IN FOR-NEXT STATEMENT :#4P 
	MOVF	SYSPRINTTEMP,W,ACCESS
	SUBWF	PRINTLEN,W,ACCESS
	MOVWF	SYSTEMP1,ACCESS
	MOVFF	SYSTEMP1,SYSBYTETEMPA
	CLRF	SYSBYTETEMPB,ACCESS
	RCALL	SYSCOMPEQUAL
	COMF	SYSBYTETEMPX,F,ACCESS
	BTFSS	SYSBYTETEMPX,0,ACCESS
	BRA	ENDIF13
;SET LOOPVAR TO LOOPVAR + STEPVALUE WHERE STEPVALUE IS A POSITIVE VALUE
	INCF	SYSPRINTTEMP,F,ACCESS
	BRA	SYSFORLOOP3
;END IF
ENDIF13
SYSFORLOOPEND3
;End If
ENDIF12
;CR
;All Usarts
;--------------------------
;Specific USARTs
;------------------
	RETURN

;********************************************************************************

;SOURCE: USART.H (2632)
HSERPRINTCRLF
;repeat HSerPrintCRLFCount
	MOVFF	HSERPRINTCRLFCOUNT,SYSREPEATTEMP2
	MOVF	SYSREPEATTEMP2,F,ACCESS
	BTFSC	STATUS, Z,ACCESS
	BRA	SYSREPEATLOOPEND2
SYSREPEATLOOP2
;HSerSend(13,comport)
	MOVLW	13
	MOVWF	SERDATA,ACCESS
	RCALL	HSERSEND805
;HSerSend(10,comport)
	MOVLW	10
	MOVWF	SERDATA,ACCESS
	RCALL	HSERSEND805
;end Repeat
	DECFSZ	SYSREPEATTEMP2,F,ACCESS
	BRA	SYSREPEATLOOP2
SYSREPEATLOOPEND2
	RETURN

;********************************************************************************

;OVERLOADED SIGNATURE: BYTE:BYTE:, SOURCE: USART.H (1553)
HSERSEND805
HSERSENDUSART1HANDLER
;USART_TX_BLOCKING
;Wait While TXIF = Off
SYSWAITLOOP1
	BANKSEL	PIR3
	BTFSS	PIR3,TX1IF,BANKED
	BRA	SYSWAITLOOP1
;Wait until TRMT = 1
SYSWAITLOOP2
	BTFSS	TX1STA,TRMT,ACCESS
	BRA	SYSWAITLOOP2
;TXREG = SerData
	MOVFF	SERDATA,TX1REG
	BANKSEL	0
	RETURN

;********************************************************************************

;SOURCE: 010_18F67K40_EXPLORER8_GLCD_SETUPVERIFICATION.GCB (274)
INITGLCD_LT686
;Harware SPI mode
;SPIMode HWSPIMODESCRIPT, 0
	MOVLW	13
	MOVWF	SPICURRENTMODE,ACCESS
	CLRF	SPICLOCKMODE,ACCESS
	RCALL	SPIMODE764
;Set LT686_CS On
	BSF	LATA,0,ACCESS
;Wait 50 ms
	MOVLW	50
	MOVWF	SYSWAITTEMPMS,ACCESS
	CLRF	SYSWAITTEMPMS_H,ACCESS
	RCALL	DELAY_MS
;Set LT686_RST On
	BSF	LATB,0,ACCESS
;Wait 15 ms
	MOVLW	15
	MOVWF	SYSWAITTEMPMS,ACCESS
	CLRF	SYSWAITTEMPMS_H,ACCESS
	RCALL	DELAY_MS
;Set LT686_RST Off
	BCF	LATB,0,ACCESS
;Wait 15 us
	MOVLW	80
	MOVWF	DELAYTEMP,ACCESS
DELAYUS1
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS1
;Set LT686_RST On
	BSF	LATB,0,ACCESS
;Wait 15 ms
	MOVLW	15
	MOVWF	SYSWAITTEMPMS,ACCESS
	CLRF	SYSWAITTEMPMS_H,ACCESS
	RCALL	DELAY_MS
;SendCommand_LT686(0xEF)
;SendData_LT686(0x03)
;GLCDBACKGROUND = TFT_BLACK
	CLRF	GLCDBACKGROUND,ACCESS
	CLRF	GLCDBACKGROUND_H,ACCESS
;GLCDForeground = TFT_WHITE
	SETF	GLCDFOREGROUND,ACCESS
	SETF	GLCDFOREGROUND_H,ACCESS
;LT686_GLCD_WIDTH = GLCD_WIDTH
	CLRF	GLCDDEVICEWIDTH,ACCESS
	MOVLW	4
	MOVWF	GLCDDEVICEWIDTH_H,ACCESS
;LT686_GLCD_HEIGHT = GLCD_HEIGHT
	MOVLW	32
	MOVWF	GLCDDEVICEHEIGHT,ACCESS
	MOVLW	3
	MOVWF	GLCDDEVICEHEIGHT_H,ACCESS
;GLCDFontWidth = 6
	MOVLW	6
	MOVWF	GLCDFONTWIDTH,ACCESS
;GLCDfntDefault = 0
	CLRF	GLCDFNTDEFAULT,ACCESS
;GLCDfntDefaultsize = 1
	MOVLW	1
	MOVWF	GLCDFNTDEFAULTSIZE,ACCESS
;GLCDfntDefaultHeight = 7   //~ used by GLCDPrintString and GLCDPrintStringLn
	MOVLW	7
	MOVWF	GLCDFNTDEFAULTHEIGHT,ACCESS
;GLCDRotateState = Portrait
	MOVLW	4
	MOVWF	GLCDROTATESTATE,ACCESS
;GLCDCLS
	BRA	GLCDCLS_LT686

;********************************************************************************

;SOURCE: LCD.H (583)
INITLCD
;asm showdebug  `LCD_IO selected is ` LCD_IO
;asm showdebug  `LCD_Speed is FAST`
;asm showdebug  `OPTIMAL is set to ` OPTIMAL
;asm showdebug  `LCD_Speed is set to ` LCD_Speed
;LCD_SPI_Expander_Initialize
	RCALL	LCD_SPI_EXPANDER_INITIALIZE
;LCD_State = 12
	MOVLW	12
	MOVWF	LCD_STATE,ACCESS
	RETURN

;********************************************************************************

;SOURCE: 010_18F67K40_EXPLORER8_GLCD_SETUPVERIFICATION.GCB (28)
INITPPS
;RC6PPS = 0x000C     //~ TX1 > RC6
	MOVLW	12
	BANKSEL	RC6PPS
	MOVWF	RC6PPS,BANKED
;This is conditional to support Hardware SPI
;SSP1CLKPPS = 0x13;   //RC3->MSSP1:SCK1;
	MOVLW	19
	MOVWF	SSP1CLKPPS,BANKED
;RC3PPS = 0x19;   //RC3->MSSP1:SCK1;
	MOVLW	25
	MOVWF	RC3PPS,BANKED
;RC5PPS = 0x1A;   //RC5->MSSP1:SDO1;
	MOVLW	26
	MOVWF	RC5PPS,BANKED
;SSP1DATPPS = 0x14;   //RC4->MSSP1:SDI1;
	MOVLW	20
	MOVWF	SSP1DATPPS,BANKED
;RC2PPS = 0x0005     //~ CCP1 > RC2
	MOVLW	5
	MOVWF	RC2PPS,BANKED
;CCP1PPS = 0x0012     //~ RC2 > CCP1 (bi-directional)
	MOVLW	18
	MOVWF	CCP1PPS,BANKED
;RE5PPS = 0x0005     //~ CCP1 > RE5
	MOVLW	5
	MOVWF	RE5PPS,BANKED
;CCP1PPS = 0x0025     //~ RE5 > CCP1 (bi-directional)
	MOVLW	37
	MOVWF	CCP1PPS,BANKED
;RE7PPS = 0x0005     //~ CCP1 > RE7
	MOVLW	5
	MOVWF	RE7PPS,BANKED
;CCP1PPS = 0x0027     //~ RE7 > CCP1 (bi-directional)
	MOVLW	39
	MOVWF	CCP1PPS,BANKED
	BANKSEL	0
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (174)
INITSYS
;Added (Per  Chip Errata Sheets) to correctly support table reads on specific chips)
;Sets NVRAM pointer to Static RAM as default location.
;NVMCON1.7 = 1
	BSF	NVMCON1,7,ACCESS
;NVMCON1.6 = 0
	BCF	NVMCON1,6,ACCESS
;Clear BSR on ChipFamily16 MCUs
;MOVLB 0
	MOVLB	0
;asm showdebug This code block sets the internal oscillator to ChipMHz
;asm showdebug Default settings for microcontrollers with _OSCCON1_
;Default OSCCON1 typically, NOSC HFINTOSC; NDIV 1 - Common as this simply sets the HFINTOSC
;OSCCON1 = 0x60
	MOVLW	96
	BANKSEL	OSCCON1
	MOVWF	OSCCON1,BANKED
;Default value typically, CSWHOLD may proceed; SOSCPWR Low power
;OSCCON3 = 0x00
	CLRF	OSCCON3,BANKED
;Default value typically, MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled
;OSCEN = 0x00
	CLRF	OSCEN,BANKED
;Default value
;OSCTUNE = 0x00
	CLRF	OSCTUNE,BANKED
;asm showdebug The MCU is a chip family ChipFamily
;Section supports many MCUs, 18FxxK40, 18FxxK42 etc that have NDIV3 bit
;asm showdebug OSCCON type is 101
;OSCCON1 = 0x60
	MOVLW	96
	MOVWF	OSCCON1,BANKED
;Clear NDIV3:0
;NDIV3 = 0
	BCF	OSCCON1,NDIV3,BANKED
;NDIV2 = 0
	BCF	OSCCON1,NDIV2,BANKED
;NDIV1 = 0
	BCF	OSCCON1,NDIV1,BANKED
;NDIV0 = 0
	BCF	OSCCON1,NDIV0,BANKED
;OSCFRQ = 0b00001000  '64mhz
	MOVLW	8
	MOVWF	OSCFRQ,BANKED
;asm showdebug _Complete_the_chip_setup_of_BSR_ADCs_ANSEL_and_other_key_setup_registers_or_register_bits
;Clear TBLPTRU on MCUs with this bit as this must be zero
;TBLPTRU = 0
	CLRF	TBLPTRU,ACCESS
;Ensure all ports are set for digital I/O and, turn off A/D
;SET ADFM OFF
	BCF	ADCON0,ADFM,ACCESS
;Switch off A/D Var(ADCON0)
;SET ADCON0.ADON OFF
	BCF	ADCON0,ADON,ACCESS
;ANSELA = 0
	CLRF	ANSELA,BANKED
;ANSELB = 0
	CLRF	ANSELB,BANKED
;ANSELD = 0
	CLRF	ANSELD,BANKED
;ANSELE = 0
	CLRF	ANSELE,BANKED
;ANSELF = 0
	CLRF	ANSELF,BANKED
;ANSELG = 0
	CLRF	ANSELG,BANKED
;Set comparator register bits for many MCUs with register CM2CON0
;C2EN = 0
	BCF	CM2CON0,C2EN,BANKED
;C1EN = 0
	BCF	CM1CON0,C1EN,BANKED
;
;'Turn off all ports
;PORTA = 0
	CLRF	PORTA,ACCESS
;PORTB = 0
	CLRF	PORTB,ACCESS
;PORTC = 0
	CLRF	PORTC,ACCESS
;PORTD = 0
	CLRF	PORTD,ACCESS
;PORTE = 0
	CLRF	PORTE,ACCESS
;PORTF = 0
	CLRF	PORTF,ACCESS
;PORTG = 0
	CLRF	PORTG,ACCESS
;PORTH = 0
	CLRF	PORTH,ACCESS
	BANKSEL	0
	RETURN

;********************************************************************************

;SOURCE: USART.H (1010)
INITUSART
;Set the default value for USART handler - required when more than one USART
;comport = 1
	MOVLW	1
	MOVWF	COMPORT,ACCESS
;PIC USART 1 Init
;Set baud rate for chips with BRG16 bit
;SPBRGH = SPBRGH_TEMP
	MOVLW	6
	MOVWF	SP1BRGH,ACCESS
;SPBRGL = SPBRGL_TEMP
	MOVLW	129
	MOVWF	SP1BRGL,ACCESS
;SPBRG = SPBRGL_TEMP
	MOVLW	129
	MOVWF	SPBRG,ACCESS
;BRG16 = BRG16_TEMP
	BSF	BAUD1CON,BRG16,ACCESS
;BRGH = BRGH_TEMP
	BSF	TX1STA,BRGH,ACCESS
;SYNC=0
	BCF	TX1STA,SYNC_TX1STA,ACCESS
;TXEN=1
	BSF	TX1STA,TXEN,ACCESS
;SPEN=1
	BSF	RC1STA,SPEN,ACCESS
;CREN=1
	BSF	RC1STA,CREN,ACCESS
	RETURN

;********************************************************************************

;SOURCE: LCD.H (532)
LCDCMD
;Sub to send specified command direct to the LCD
;SET LCD_RS OFF
	BCF	SYSLCDTEMP,1,ACCESS
;LCDWriteByte ( LCDValue)
	MOVFF	LCDVALUE,LCDBYTE
	RCALL	LCD_SPI_EXPANDER_NORMALWRITEBYTE
;IF LCDValue = 1 OR LCDValue = 2 then  ' HOME or CLEAR
	MOVFF	LCDVALUE,SYSBYTETEMPA
	MOVLW	1
	MOVWF	SYSBYTETEMPB,ACCESS
	RCALL	SYSCOMPEQUAL
	MOVFF	SYSBYTETEMPX,SYSTEMP1
	MOVFF	LCDVALUE,SYSBYTETEMPA
	MOVLW	2
	MOVWF	SYSBYTETEMPB,ACCESS
	RCALL	SYSCOMPEQUAL
	MOVF	SYSTEMP1,W,ACCESS
	IORWF	SYSBYTETEMPX,W,ACCESS
	MOVWF	SYSTEMP2,ACCESS
	BTFSS	SYSTEMP2,0,ACCESS
	BRA	ELSE14_1
;Wait 2 ms ' Must be > 1.52 ms
	MOVLW	2
	MOVWF	SYSWAITTEMPMS,ACCESS
	CLRF	SYSWAITTEMPMS_H,ACCESS
	RCALL	DELAY_MS
;Else
	BRA	ENDIF14
ELSE14_1
;Wait 50 us
	MOVLW	1
	MOVWF	DELAYTEMP2,ACCESS
DELAYUSO7
	CLRF	DELAYTEMP,ACCESS
DELAYUS7
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS7
	DECFSZ	DELAYTEMP2,F,ACCESS
	BRA	DELAYUSO7
	MOVLW	9
	MOVWF	DELAYTEMP,ACCESS
DELAYUS8
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS8
;END IF
ENDIF14
	RETURN

;********************************************************************************

;SOURCE: LCD.H (2452)
LCD_SPI_EXPANDER_INITIALIZE
;Dir LCD_SPI_RESET_OUT Out
	BCF	TRISB,5,ACCESS
;'Reset the expander
;Reset sequence (lower line for at least 1 us)
;wait 10 ms
	MOVLW	10
	MOVWF	SYSWAITTEMPMS,ACCESS
	CLRF	SYSWAITTEMPMS_H,ACCESS
	RCALL	DELAY_MS
;LCD_SPI_RESET_OUT = 0
	BCF	LATB,5,ACCESS
;Wait 5 us
	MOVLW	26
	MOVWF	DELAYTEMP,ACCESS
DELAYUS6
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS6
	NOP
;LCD_SPI_RESET_OUT = 1
	BSF	LATB,5,ACCESS
;Dir LCD_SPI_CS      Out
	BCF	TRISA,2,ACCESS
;Dir LCD_SPI_DO      Out
	BCF	TRISC,5,ACCESS
;Dir LCD_SPI_SCK     Out
	BCF	TRISC,3,ACCESS
;asm showdebug SPI constant used equates to HWSPIMODESCRIPT
;SPIMode HWSPIMODESCRIPT, 0
	MOVLW	13
	MOVWF	SPICURRENTMODE,ACCESS
	CLRF	SPICLOCKMODE,ACCESS
	RCALL	SPIMODE764
;LCD_SPI_WriteIOExpander(IO_DIR_A_ADDRESS, OUTPUT_DIR)
	CLRF	__LCDREG,ACCESS
	CLRF	__LCDBYTE,ACCESS
	RCALL	LCD_SPI_WRITEIOEXPANDER
;wait 10 ms
	MOVLW	10
	MOVWF	SYSWAITTEMPMS,ACCESS
	CLRF	SYSWAITTEMPMS_H,ACCESS
	RCALL	DELAY_MS
;LCD_SPI_WriteIOExpander(IO_DIR_B_ADDRESS, OUTPUT_DIR)
	MOVLW	1
	MOVWF	__LCDREG,ACCESS
	CLRF	__LCDBYTE,ACCESS
	RCALL	LCD_SPI_WRITEIOEXPANDER
;wait 10 ms
	MOVLW	10
	MOVWF	SYSWAITTEMPMS,ACCESS
	CLRF	SYSWAITTEMPMS_H,ACCESS
	RCALL	DELAY_MS
;LCD_SPI_WriteIOExpander(GPIO_A_ADDRESS, LCD_VDD_EN)
	MOVLW	18
	MOVWF	__LCDREG,ACCESS
	MOVLW	32
	MOVWF	__LCDBYTE,ACCESS
	RCALL	LCD_SPI_WRITEIOEXPANDER
;wait 10 ms
	MOVLW	10
	MOVWF	SYSWAITTEMPMS,ACCESS
	CLRF	SYSWAITTEMPMS_H,ACCESS
	RCALL	DELAY_MS
;LCDCmd(LCD_FUNCTION_SET)
	MOVLW	60
	MOVWF	LCDVALUE,ACCESS
	RCALL	LCDCMD
;wait 10 ms;
	MOVLW	10
	MOVWF	SYSWAITTEMPMS,ACCESS
	CLRF	SYSWAITTEMPMS_H,ACCESS
	RCALL	DELAY_MS
;LCDCmd(LCD_SET_DISPLAY)
	MOVLW	12
	MOVWF	LCDVALUE,ACCESS
	RCALL	LCDCMD
;wait 10 ms;
	MOVLW	10
	MOVWF	SYSWAITTEMPMS,ACCESS
	CLRF	SYSWAITTEMPMS_H,ACCESS
	RCALL	DELAY_MS
;LCDCmd(LCD_CLEAR)
	MOVLW	1
	MOVWF	LCDVALUE,ACCESS
	RCALL	LCDCMD
;wait 10 ms;
	MOVLW	10
	MOVWF	SYSWAITTEMPMS,ACCESS
	CLRF	SYSWAITTEMPMS_H,ACCESS
	RCALL	DELAY_MS
;LCDCmd(LCD_SET_DISPLAY)
	MOVLW	12
	MOVWF	LCDVALUE,ACCESS
	RCALL	LCDCMD
;wait 130 ms
	MOVLW	130
	MOVWF	SYSWAITTEMPMS,ACCESS
	CLRF	SYSWAITTEMPMS_H,ACCESS
	RCALL	DELAY_MS
;LCDCmd(LCD_SET_DDRAM_ADDRESS)
	MOVLW	128
	MOVWF	LCDVALUE,ACCESS
	RCALL	LCDCMD
;wait 1 ms
	MOVLW	1
	MOVWF	SYSWAITTEMPMS,ACCESS
	CLRF	SYSWAITTEMPMS_H,ACCESS
	BRA	DELAY_MS

;********************************************************************************

;SOURCE: LCD.H (2404)
LCD_SPI_EXPANDER_NORMALWRITEBYTE
;Sub to write a byte to the LCD
;Default values - these are the address on the expander
;LCD_SPI_EXPANDER_ENABLED = 0x20
;LCD_SPI_EXPANDER_E_ADDRESS = 0x40
;LCD_SPI_EXPANDER_RS_ADDRESS = 0x80
;
;Dim LCD_State as Byte
;If LCD_RS = 0 Then
	BTFSC	SYSLCDTEMP,1,ACCESS
	BRA	ELSE4_1
;R
;SE
;LCD_SPI_WriteIOExpander(GPIO_A_ADDRESS, LCD_SPI_EXPANDER_ENABLED + LCD_SPI_EXPANDER_E_ADDRESS);     //RS LOW -- E HIGH -- LCD Enabled       01100000
	MOVLW	18
	MOVWF	__LCDREG,ACCESS
	MOVLW	96
	MOVWF	__LCDBYTE,ACCESS
	RCALL	LCD_SPI_WRITEIOEXPANDER
;LCD_SPI_WriteIOExpander(GPIO_B_ADDRESS, LCDByte);   //Write the command on PORT B        E
	MOVLW	19
	MOVWF	__LCDREG,ACCESS
	MOVFF	LCDBYTE,__LCDBYTE
	RCALL	LCD_SPI_WRITEIOEXPANDER
	MOVFF	__LCDBYTE,LCDBYTE
;LCD_SPI_WriteIOExpander(GPIO_A_ADDRESS, LCD_SPI_EXPANDER_ENABLED);                                  //RS LOW -- E LOW -- LCD Enabled        00100000
	MOVLW	18
	MOVWF	__LCDREG,ACCESS
	MOVLW	32
	MOVWF	__LCDBYTE,ACCESS
	RCALL	LCD_SPI_WRITEIOEXPANDER
;Else
	BRA	ENDIF4
ELSE4_1
;R
;SE
;11100000
;LCD_SPI_WriteIOExpander(GPIO_A_ADDRESS, LCD_SPI_EXPANDER_ENABLED + LCD_SPI_EXPANDER_E_ADDRESS + LCD_SPI_EXPANDER_RS_ADDRESS );       //RS HIGH -- E HIGH -- LCD Enabled --> This is to choose the data register on the LCD
	MOVLW	18
	MOVWF	__LCDREG,ACCESS
	MOVLW	224
	MOVWF	__LCDBYTE,ACCESS
	RCALL	LCD_SPI_WRITEIOEXPANDER
;LCD_SPI_WriteIOExpander(GPIO_B_ADDRESS, LCDByte);  //Write the byte on PORT B
	MOVLW	19
	MOVWF	__LCDREG,ACCESS
	MOVFF	LCDBYTE,__LCDBYTE
	RCALL	LCD_SPI_WRITEIOEXPANDER
	MOVFF	__LCDBYTE,LCDBYTE
;R
;SE
;10100000
;LCD_SPI_WriteIOExpander(GPIO_A_ADDRESS, LCD_SPI_EXPANDER_ENABLED + LCD_SPI_EXPANDER_RS_ADDRESS );                       //RS HIGH -- E LOW -- LCD enabled --> This is to latch the data on the LCD
	MOVLW	18
	MOVWF	__LCDREG,ACCESS
	MOVLW	160
	MOVWF	__LCDBYTE,ACCESS
	RCALL	LCD_SPI_WRITEIOEXPANDER
;End IF
ENDIF4
;LCD_State = 12
	MOVLW	12
	MOVWF	LCD_STATE,ACCESS
;WAIT LCD_SPEED us
	MOVLW	1
	MOVWF	DELAYTEMP2,ACCESS
DELAYUSO4
	CLRF	DELAYTEMP,ACCESS
DELAYUS4
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS4
	DECFSZ	DELAYTEMP2,F,ACCESS
	BRA	DELAYUSO4
	MOVLW	9
	MOVWF	DELAYTEMP,ACCESS
DELAYUS5
	DECFSZ	DELAYTEMP,F,ACCESS
	BRA	DELAYUS5
;If Register Select is low
;IF LCD_RS = 0 then
	BTFSC	SYSLCDTEMP,1,ACCESS
	BRA	ENDIF5
;IF LCDByte < 16 then
	MOVLW	16
	SUBWF	LCDBYTE,W,ACCESS
	BTFSC	STATUS, C,ACCESS
	BRA	ENDIF6
;if LCDByte > 7 then
	MOVF	LCDBYTE,W,ACCESS
	SUBLW	7
	BTFSS	STATUS, C,ACCESS
;LCD_State = LCDByte
	MOVFF	LCDBYTE,LCD_STATE
;end if
;END IF
ENDIF6
;END IF
ENDIF5
	RETURN

;********************************************************************************

;SOURCE: LCD.H (2498)
LCD_SPI_WRITEIOEXPANDER
;LCD_SPI_CS = 0
	BCF	LATA,2,ACCESS
;Set the three parameters using Bit Banging
;dim __LCD_outbuffer, __LCD_outbuffercount
;For __LCD_outbuffercount = 0 to 2
;LEGACY METHOD
	SETF	__LCD_OUTBUFFERCOUNT,ACCESS
SYSFORLOOP2
	INCF	__LCD_OUTBUFFERCOUNT,F,ACCESS
;Select Case __LCD_outbuffercount
;Case 0: __LCD_outbuffer = LCD_SPI_EXPD_ADDRESS
SYSSELECT1CASE1
	MOVF	__LCD_OUTBUFFERCOUNT,F,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	SYSSELECT1CASE2
;Case 0: __LCD_outbuffer = LCD_SPI_EXPD_ADDRESS
	MOVLW	64
	MOVWF	__LCD_OUTBUFFER,ACCESS
;Case 1: __LCD_outbuffer = __LCDreg
	BRA	SYSSELECTEND1
SYSSELECT1CASE2
	DECF	__LCD_OUTBUFFERCOUNT,W,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	SYSSELECT1CASE3
;Case 1: __LCD_outbuffer = __LCDreg
	MOVFF	__LCDREG,__LCD_OUTBUFFER
;Case 2: __LCD_outbuffer = __LCDbyte
	BRA	SYSSELECTEND1
SYSSELECT1CASE3
	MOVLW	2
	SUBWF	__LCD_OUTBUFFERCOUNT,W,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	SYSSELECTEND1
;Case 2: __LCD_outbuffer = __LCDbyte
	MOVFF	__LCDBYTE,__LCD_OUTBUFFER
;End Select
SYSSELECTEND1
;repeat 8
	MOVLW	8
	MOVWF	SYSREPEATTEMP1,ACCESS
SYSREPEATLOOP1
;if __LCD_outbuffer.7 = ON  then
	BTFSS	__LCD_OUTBUFFER,7,ACCESS
	BRA	ELSE8_1
;set LCD_SPI_DO ON;
	BSF	LATC,5,ACCESS
;else
	BRA	ENDIF8
ELSE8_1
;set LCD_SPI_DO OFF;
	BCF	LATC,5,ACCESS
;end if
ENDIF8
;SET LCD_SPI_SCK On;
	BSF	LATC,3,ACCESS
;rotate __LCD_outbuffer left
	RLCF	__LCD_OUTBUFFER,F,ACCESS
;set LCD_SPI_SCK Off;
	BCF	LATC,3,ACCESS
;end repeat
	DECFSZ	SYSREPEATTEMP1,F,ACCESS
	BRA	SYSREPEATLOOP1
SYSREPEATLOOPEND1
;Next
	MOVLW	2
	SUBWF	__LCD_OUTBUFFERCOUNT,W,ACCESS
	BTFSS	STATUS, C,ACCESS
	BRA	SYSFORLOOP2
SYSFORLOOPEND2
;LCD_SPI_CS = 1
	BSF	LATA,2,ACCESS
	RETURN

;********************************************************************************

;SOURCE: LCD.H (496)
LOCATE
;Sub to locate the cursor
;Where LCDColumn is 0 to screen width-1, LCDLine is 0 to screen height-1
;Set LCD_RS Off
	BCF	SYSLCDTEMP,1,ACCESS
;If LCDLine > 1 Then
	MOVF	LCDLINE,W,ACCESS
	SUBLW	1
	BTFSC	STATUS, C,ACCESS
	BRA	ENDIF1
;LCDLine = LCDLine - 2
	MOVLW	2
	SUBWF	LCDLINE,F,ACCESS
;LCDColumn = LCDColumn + LCD_WIDTH
	MOVLW	20
	ADDWF	LCDCOLUMN,F,ACCESS
;End If
ENDIF1
;LCDWriteByte(0x80 or 0x40 * LCDLine + LCDColumn)
	MOVF	LCDLINE,W,ACCESS
	MULLW	64
	MOVF	LCDCOLUMN,W,ACCESS
	ADDWF	PRODL,W,ACCESS
	MOVWF	SYSTEMP1,ACCESS
	MOVLW	128
	IORWF	SYSTEMP1,W,ACCESS
	MOVWF	LCDBYTE,ACCESS
	RCALL	LCD_SPI_EXPANDER_NORMALWRITEBYTE
;wait 5 10us
	MOVLW	5
	MOVWF	SYSWAITTEMP10US,ACCESS
	BRA	DELAY_10US

;********************************************************************************

;OVERLOADED SIGNATURE: STRING:, SOURCE: LCD.H (935)
PRINT612
;Sub to print a string variable on the LCD
;PrintLen = PrintData(0)
	MOVFF	SYSPRINTDATAHANDLER,AFSR0
	MOVFF	SYSPRINTDATAHANDLER_H,AFSR0_H
	MOVFF	INDF0,PRINTLEN
;If PrintLen = 0 Then Exit Sub
	MOVF	PRINTLEN,F,ACCESS
	BTFSC	STATUS, Z,ACCESS
;If PrintLen = 0 Then Exit Sub
	RETURN
;If PrintLen = 0 Then Exit Sub
;Set LCD_RS On
	BSF	SYSLCDTEMP,1,ACCESS
;Write Data
;For SysPrintTemp = 1 To PrintLen
	MOVLW	1
	MOVWF	SYSPRINTTEMP,ACCESS
SYSFORLOOP1
;LCDWriteByte PrintData(SysPrintTemp)
	MOVF	SYSPRINTTEMP,W,ACCESS
	ADDWF	SYSPRINTDATAHANDLER,W,ACCESS
	MOVWF	AFSR0,ACCESS
	MOVLW	0
	ADDWFC	SYSPRINTDATAHANDLER_H,W,ACCESS
	MOVWF	AFSR0_H,ACCESS
	MOVFF	INDF0,LCDBYTE
	RCALL	LCD_SPI_EXPANDER_NORMALWRITEBYTE
;Next
;POSITIVE VALUE STEP HANDLER IN FOR-NEXT STATEMENT :#4P 
	MOVF	SYSPRINTTEMP,W,ACCESS
	SUBWF	PRINTLEN,W,ACCESS
	MOVWF	SYSTEMP1,ACCESS
	MOVFF	SYSTEMP1,SYSBYTETEMPA
	CLRF	SYSBYTETEMPB,ACCESS
	RCALL	SYSCOMPEQUAL
	COMF	SYSBYTETEMPX,F,ACCESS
	BTFSS	SYSBYTETEMPX,0,ACCESS
	BRA	ENDIF3
;SET LOOPVAR TO LOOPVAR + STEPVALUE WHERE STEPVALUE IS A POSITIVE VALUE
	INCF	SYSPRINTTEMP,F,ACCESS
	BRA	SYSFORLOOP1
;END IF
ENDIF3
SYSFORLOOPEND1
	RETURN

;********************************************************************************

;OVERLOADED SIGNATURE: BYTE:BYTE:, SOURCE: HWSPI.H (382)
SPIMODE764
;Supports Legacy SPI via MSSP module
;added for 16f18855
;added for 16f18855
;added for 16f18855
;Turn off SPI
;(Prevents any weird glitches during setup)
;Set SSPCON1.SSPEN Off ;(Prevents any weird glitches during setup)
	BCF	SSP1CON1,SSPEN,ACCESS
;Set clock pulse settings
;Set SSPSTAT.SMP Off
	BCF	SSP1STAT,SMP,ACCESS
;Set SSPSTAT.CKE Off
	BCF	SSP1STAT,CKE,ACCESS
;If SPIClockMode.0 = Off Then
	BTFSS	SPICLOCKMODE,0,ACCESS
;Set SSPSTAT.CKE On
	BSF	SSP1STAT,CKE,ACCESS
;End If
;Set SSPCON1.CKP Off
	BCF	SSP1CON1,CKP,ACCESS
;If SPIClockMode.1 = On Then
	BTFSC	SPICLOCKMODE,1,ACCESS
;Set SSPCON1.CKP On
	BSF	SSP1CON1,CKP,ACCESS
;End If
;Select mode and clock
;Set some mode bits off, can set on later
;Set SSPCON1.SSPM3 Off
	BCF	SSP1CON1,SSPM3,ACCESS
;Set SSPCON1.SSPM2 Off
	BCF	SSP1CON1,SSPM2,ACCESS
;Set SSPCON1.SSPM1 Off
	BCF	SSP1CON1,SSPM1,ACCESS
;Set SSPCON1.SSPM0 Off
	BCF	SSP1CON1,SSPM0,ACCESS
;Select Case SPICurrentMode
;Case MasterSSPADDMode   '1010
SYSSELECT2CASE1
	MOVLW	16
	SUBWF	SPICURRENTMODE,W,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	SYSSELECT2CASE2
;Set SSPCON1.SSPM3 On
	BSF	SSP1CON1,SSPM3,ACCESS
;Set SSPCON1.SSPM1 On
	BSF	SSP1CON1,SSPM1,ACCESS
;SSP1ADD = 1
	MOVLW	1
	MOVWF	SSP1ADD,ACCESS
;Case MasterUltraFast
	BRA	SYSSELECTEND2
SYSSELECT2CASE2
	MOVLW	14
	SUBWF	SPICURRENTMODE,W,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	SYSSELECT2CASE3
;Nothing to do on PIC
;Case MasterFast
	BRA	SYSSELECTEND2
SYSSELECT2CASE3
	MOVLW	13
	SUBWF	SPICURRENTMODE,W,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	SYSSELECT2CASE4
;Nothing to do
;Case Master
	BRA	SYSSELECTEND2
SYSSELECT2CASE4
	MOVLW	12
	SUBWF	SPICURRENTMODE,W,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	SYSSELECT2CASE5
;Set SSPCON1.SSPM0 On
	BSF	SSP1CON1,SSPM0,ACCESS
;Case MasterSlow
	BRA	SYSSELECTEND2
SYSSELECT2CASE5
	MOVLW	11
	SUBWF	SPICURRENTMODE,W,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	SYSSELECT2CASE6
;Set SSPCON1.SSPM1 On
	BSF	SSP1CON1,SSPM1,ACCESS
;Case Slave
	BRA	SYSSELECTEND2
SYSSELECT2CASE6
	MOVF	SPICURRENTMODE,F,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	SYSSELECT2CASE7
;Set SSPCON1.SSPM2 On
	BSF	SSP1CON1,SSPM2,ACCESS
;Set SSPCON1.SSPM0 On
	BSF	SSP1CON1,SSPM0,ACCESS
;Case SlaveSS
	BRA	SYSSELECTEND2
SYSSELECT2CASE7
	DECF	SPICURRENTMODE,W,ACCESS
	BTFSS	STATUS, Z,ACCESS
	BRA	SYSSELECTEND2
;Set SSPCON1.SSPM2 On
	BSF	SSP1CON1,SSPM2,ACCESS
;End Select
SYSSELECTEND2
;Enable SPI
;Set SSPCON1.SSPEN On
	BSF	SSP1CON1,SSPEN,ACCESS
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (3102)
SYSCOMPEQUAL
;Dim SysByteTempA, SysByteTempB, SysByteTempX as byte
;setf SysByteTempX
	SETF	SYSBYTETEMPX,ACCESS
;movf SysByteTempB, W
	MOVF	SYSBYTETEMPB, W,ACCESS
;cpfseq SysByteTempA
	CPFSEQ	SYSBYTETEMPA,ACCESS
;clrf SysByteTempX
	CLRF	SYSBYTETEMPX,ACCESS
	RETURN

;********************************************************************************

;SOURCE: SYSTEM.H (1595)
SYSREADSTRING
;Dim SysCalcTempA As Byte
;Dim SysStringLength As Byte
;ChipFamily 16 support
;Get length
;TBLRD*+
	TBLRD*+
;movff TABLAT,SysCalcTempA
	MOVFF	TABLAT,SYSCALCTEMPA
;movff TABLAT,INDF1
	MOVFF	TABLAT,INDF1
;goto SysStringReadCheck
	BRA	SYSSTRINGREADCHECK
SYSREADSTRINGPART
;TBLRD*+
	TBLRD*+
;movf TABLAT, W
	MOVF	TABLAT, W,ACCESS
;movwf SysCalcTempA
	MOVWF	SYSCALCTEMPA,ACCESS
;addwf SysStringLength,F
	ADDWF	SYSSTRINGLENGTH,F,ACCESS
;Check length
SYSSTRINGREADCHECK
;If length is 0, exit
;movf SysCalcTempA,F
	MOVF	SYSCALCTEMPA,F,ACCESS
;btfsc STATUS,Z
	BTFSC	STATUS,Z,ACCESS
;return
	RETURN
;Copy
SYSSTRINGREAD
;Copy char
;TBLRD*+
	TBLRD*+
;movff TABLAT,PREINC1
	MOVFF	TABLAT,PREINC1
;decfsz SysCalcTempA, F
	DECFSZ	SYSCALCTEMPA, F,ACCESS
;goto SysStringRead
	BRA	SYSSTRINGREAD
	RETURN

;********************************************************************************

SYSSTRINGTABLES

STRINGTABLE1
	DB	21,87,101,108,99,111,109,101,32,116,111,32,69,120,112,108,111,114,101,114,32,56


STRINGTABLE2
	DB	24,71,67,66,65,83,73,67,32,45,32,65,110,111,98,105,117,109,32,32,32,50,48,50,51


STRINGTABLE3
	DB	16,32,32,32,32,87,101,108,99,111,109,101,32,32,32,32,32


STRINGTABLE4
	DB	16,32,32,116,111,32,69,120,112,108,111,114,101,114,32,56,32


STRINGTABLE5
	DB	16,32,32,32,32,71,67,66,65,83,73,67,32,32,32,32,32


STRINGTABLE6
	DB	16,32,65,110,111,98,105,117,109,32,32,32,50,48,50,51,32


;********************************************************************************


 END
